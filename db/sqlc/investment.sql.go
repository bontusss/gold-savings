// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: investment.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createInvestment = `-- name: CreateInvestment :one
INSERT INTO investments (
  user_id, plan_id, amount, interest, interest_rate, status, reference_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, plan_id, reference_id, amount, interest, interest_rate, status, start_date, end_date, created_at, updated_at
`

type CreateInvestmentParams struct {
	UserID       uuid.UUID `json:"user_id"`
	PlanID       int32     `json:"plan_id"`
	Amount       int32     `json:"amount"`
	Interest     string    `json:"interest"`
	InterestRate string    `json:"interest_rate"`
	Status       string    `json:"status"`
	ReferenceID  string    `json:"reference_id"`
}

func (q *Queries) CreateInvestment(ctx context.Context, arg CreateInvestmentParams) (Investment, error) {
	row := q.db.QueryRowContext(ctx, createInvestment,
		arg.UserID,
		arg.PlanID,
		arg.Amount,
		arg.Interest,
		arg.InterestRate,
		arg.Status,
		arg.ReferenceID,
	)
	var i Investment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.ReferenceID,
		&i.Amount,
		&i.Interest,
		&i.InterestRate,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSavings = `-- name: CreateSavings :one
INSERT INTO savings (
  user_id, amount
) VALUES (
  $1, $2
)
RETURNING id, user_id, amount, created_at, updated_at
`

type CreateSavingsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Amount string    `json:"amount"`
}

func (q *Queries) CreateSavings(ctx context.Context, arg CreateSavingsParams) (Saving, error) {
	row := q.db.QueryRowContext(ctx, createSavings, arg.UserID, arg.Amount)
	var i Saving
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteInvestment = `-- name: DeleteInvestment :exec
DELETE FROM investments
WHERE id = $1
`

func (q *Queries) DeleteInvestment(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteInvestment, id)
	return err
}

const deleteSavings = `-- name: DeleteSavings :exec
DELETE FROM savings
WHERE id = $1
`

func (q *Queries) DeleteSavings(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSavings, id)
	return err
}

const getInvestmentByID = `-- name: GetInvestmentByID :one
SELECT id, user_id, plan_id, reference_id, amount, interest, interest_rate, status, start_date, end_date, created_at, updated_at FROM investments
WHERE id = $1
`

func (q *Queries) GetInvestmentByID(ctx context.Context, id uuid.UUID) (Investment, error) {
	row := q.db.QueryRowContext(ctx, getInvestmentByID, id)
	var i Investment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.ReferenceID,
		&i.Amount,
		&i.Interest,
		&i.InterestRate,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getInvestmentByRefCode = `-- name: GetInvestmentByRefCode :one
SELECT id, user_id, plan_id, reference_id, amount, interest, interest_rate, status, start_date, end_date, created_at, updated_at FROM investments
WHERE reference_id = $1
`

func (q *Queries) GetInvestmentByRefCode(ctx context.Context, referenceID string) (Investment, error) {
	row := q.db.QueryRowContext(ctx, getInvestmentByRefCode, referenceID)
	var i Investment
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PlanID,
		&i.ReferenceID,
		&i.Amount,
		&i.Interest,
		&i.InterestRate,
		&i.Status,
		&i.StartDate,
		&i.EndDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSavingsByID = `-- name: GetSavingsByID :one
SELECT id, user_id, amount, created_at, updated_at FROM savings
WHERE id = $1
`

func (q *Queries) GetSavingsByID(ctx context.Context, id uuid.UUID) (Saving, error) {
	row := q.db.QueryRowContext(ctx, getSavingsByID, id)
	var i Saving
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserFromInestmentID = `-- name: GetUserFromInestmentID :one
SELECT user_id FROM investments
WHERE id = $1
`

func (q *Queries) GetUserFromInestmentID(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getUserFromInestmentID, id)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const listInvestmentsByPlan = `-- name: ListInvestmentsByPlan :many
SELECT id, user_id, plan_id, reference_id, amount, interest, interest_rate, status, start_date, end_date, created_at, updated_at FROM investments
WHERE plan_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListInvestmentsByPlan(ctx context.Context, planID int32) ([]Investment, error) {
	rows, err := q.db.QueryContext(ctx, listInvestmentsByPlan, planID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Investment{}
	for rows.Next() {
		var i Investment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PlanID,
			&i.ReferenceID,
			&i.Amount,
			&i.Interest,
			&i.InterestRate,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvestmentsByUser = `-- name: ListInvestmentsByUser :many
SELECT id, user_id, plan_id, reference_id, amount, interest, interest_rate, status, start_date, end_date, created_at, updated_at FROM investments
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListInvestmentsByUser(ctx context.Context, userID uuid.UUID) ([]Investment, error) {
	rows, err := q.db.QueryContext(ctx, listInvestmentsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Investment{}
	for rows.Next() {
		var i Investment
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PlanID,
			&i.ReferenceID,
			&i.Amount,
			&i.Interest,
			&i.InterestRate,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInvestmentsWithUserAndPlan = `-- name: ListInvestmentsWithUserAndPlan :many
SELECT
  investments.id,
  investments.reference_id,
  investments.amount,
  investments.interest,
  investments.interest_rate,
  investments.status,
  investments.start_date,
  investments.end_date,
  investments.created_at,
  investments.updated_at,

  users.id AS user_id,
  users.username,
  users.email,

  investment_plans.id AS plan_id,
  investment_plans.name AS plan_name

FROM investments
JOIN users ON users.id = investments.user_id
JOIN investment_plans ON investment_plans.id = investments.plan_id
ORDER BY investments.created_at DESC
`

type ListInvestmentsWithUserAndPlanRow struct {
	ID           uuid.UUID    `json:"id"`
	ReferenceID  string       `json:"reference_id"`
	Amount       int32        `json:"amount"`
	Interest     string       `json:"interest"`
	InterestRate string       `json:"interest_rate"`
	Status       string       `json:"status"`
	StartDate    sql.NullTime `json:"start_date"`
	EndDate      sql.NullTime `json:"end_date"`
	CreatedAt    time.Time    `json:"created_at"`
	UpdatedAt    time.Time    `json:"updated_at"`
	UserID       uuid.UUID    `json:"user_id"`
	Username     string       `json:"username"`
	Email        string       `json:"email"`
	PlanID       int32        `json:"plan_id"`
	PlanName     string       `json:"plan_name"`
}

func (q *Queries) ListInvestmentsWithUserAndPlan(ctx context.Context) ([]ListInvestmentsWithUserAndPlanRow, error) {
	rows, err := q.db.QueryContext(ctx, listInvestmentsWithUserAndPlan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListInvestmentsWithUserAndPlanRow{}
	for rows.Next() {
		var i ListInvestmentsWithUserAndPlanRow
		if err := rows.Scan(
			&i.ID,
			&i.ReferenceID,
			&i.Amount,
			&i.Interest,
			&i.InterestRate,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UserID,
			&i.Username,
			&i.Email,
			&i.PlanID,
			&i.PlanName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSavingsByUserID = `-- name: ListSavingsByUserID :many
SELECT id, user_id, amount, created_at, updated_at FROM savings
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListSavingsByUserID(ctx context.Context, userID uuid.UUID) ([]Saving, error) {
	rows, err := q.db.QueryContext(ctx, listSavingsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Saving{}
	for rows.Next() {
		var i Saving
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserInvestmentsWithPlan = `-- name: ListUserInvestmentsWithPlan :many
SELECT
    i.id, i.user_id, i.plan_id, i.reference_id, i.amount, i.interest, i.interest_rate, i.status, i.start_date, i.end_date, i.created_at, i.updated_at,
    p.name AS plan_name
FROM investments i
JOIN investment_plans p ON i.plan_id = p.id
WHERE i.user_id = $1
ORDER BY i.created_at DESC
`

type ListUserInvestmentsWithPlanRow struct {
	ID           uuid.UUID    `json:"id"`
	UserID       uuid.UUID    `json:"user_id"`
	PlanID       int32        `json:"plan_id"`
	ReferenceID  string       `json:"reference_id"`
	Amount       int32        `json:"amount"`
	Interest     string       `json:"interest"`
	InterestRate string       `json:"interest_rate"`
	Status       string       `json:"status"`
	StartDate    sql.NullTime `json:"start_date"`
	EndDate      sql.NullTime `json:"end_date"`
	CreatedAt    time.Time    `json:"created_at"`
	UpdatedAt    time.Time    `json:"updated_at"`
	PlanName     string       `json:"plan_name"`
}

func (q *Queries) ListUserInvestmentsWithPlan(ctx context.Context, userID uuid.UUID) ([]ListUserInvestmentsWithPlanRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserInvestmentsWithPlan, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListUserInvestmentsWithPlanRow{}
	for rows.Next() {
		var i ListUserInvestmentsWithPlanRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PlanID,
			&i.ReferenceID,
			&i.Amount,
			&i.Interest,
			&i.InterestRate,
			&i.Status,
			&i.StartDate,
			&i.EndDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PlanName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInvestmentInterest = `-- name: UpdateInvestmentInterest :exec
UPDATE investments
SET interest = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateInvestmentInterestParams struct {
	ID       uuid.UUID `json:"id"`
	Interest string    `json:"interest"`
}

func (q *Queries) UpdateInvestmentInterest(ctx context.Context, arg UpdateInvestmentInterestParams) error {
	_, err := q.db.ExecContext(ctx, updateInvestmentInterest, arg.ID, arg.Interest)
	return err
}

const updateInvestmentStatus = `-- name: UpdateInvestmentStatus :exec
UPDATE investments
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateInvestmentStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateInvestmentStatus(ctx context.Context, arg UpdateInvestmentStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateInvestmentStatus, arg.ID, arg.Status)
	return err
}

const updateSavingsAmount = `-- name: UpdateSavingsAmount :one
UPDATE savings
SET amount = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, user_id, amount, created_at, updated_at
`

type UpdateSavingsAmountParams struct {
	ID     uuid.UUID `json:"id"`
	Amount string    `json:"amount"`
}

func (q *Queries) UpdateSavingsAmount(ctx context.Context, arg UpdateSavingsAmountParams) (Saving, error) {
	row := q.db.QueryRowContext(ctx, updateSavingsAmount, arg.ID, arg.Amount)
	var i Saving
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
