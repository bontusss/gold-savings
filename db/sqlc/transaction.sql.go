// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"
)

const createPayoutRequest = `-- name: CreatePayoutRequest :one
INSERT INTO payout_requests (
  user_id, account_name, bank_name,account_number, investment_id, type, category, amount, phone_number
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, user_id, account_name, phone_number, bank_name, account_number, investment_id, type, category, amount, created_at, updated_at
`

type CreatePayoutRequestParams struct {
	UserID        int32          `json:"user_id"`
	AccountName   sql.NullString `json:"account_name"`
	BankName      sql.NullString `json:"bank_name"`
	AccountNumber sql.NullString `json:"account_number"`
	InvestmentID  sql.NullInt32  `json:"investment_id"`
	Type          string         `json:"type"`
	Category      string         `json:"category"`
	Amount        string         `json:"amount"`
	PhoneNumber   sql.NullString `json:"phone_number"`
}

func (q *Queries) CreatePayoutRequest(ctx context.Context, arg CreatePayoutRequestParams) (PayoutRequest, error) {
	row := q.db.QueryRowContext(ctx, createPayoutRequest,
		arg.UserID,
		arg.AccountName,
		arg.BankName,
		arg.AccountNumber,
		arg.InvestmentID,
		arg.Type,
		arg.Category,
		arg.Amount,
		arg.PhoneNumber,
	)
	var i PayoutRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountName,
		&i.PhoneNumber,
		&i.BankName,
		&i.AccountNumber,
		&i.InvestmentID,
		&i.Type,
		&i.Category,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
  user_id, amount, type, investment_id, status, reason, category
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, amount, investment_id, category, status, type, reason, created_at, updated_at
`

type CreateTransactionParams struct {
	UserID       int32          `json:"user_id"`
	Amount       int32          `json:"amount"`
	Type         string         `json:"type"`
	InvestmentID sql.NullInt32  `json:"investment_id"`
	Status       string         `json:"status"`
	Reason       sql.NullString `json:"reason"`
	Category     string         `json:"category"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.UserID,
		arg.Amount,
		arg.Type,
		arg.InvestmentID,
		arg.Status,
		arg.Reason,
		arg.Category,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.InvestmentID,
		&i.Category,
		&i.Status,
		&i.Type,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayoutRequestByID = `-- name: GetPayoutRequestByID :one
SELECT id, user_id, account_name, phone_number, bank_name, account_number, investment_id, type, category, amount, created_at, updated_at FROM payout_requests
WHERE id = $1
`

func (q *Queries) GetPayoutRequestByID(ctx context.Context, id int32) (PayoutRequest, error) {
	row := q.db.QueryRowContext(ctx, getPayoutRequestByID, id)
	var i PayoutRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountName,
		&i.PhoneNumber,
		&i.BankName,
		&i.AccountNumber,
		&i.InvestmentID,
		&i.Type,
		&i.Category,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRejectedTransactions = `-- name: GetRejectedTransactions :many
SELECT id, user_id, amount, investment_id, category, status, type, reason, created_at, updated_at FROM transactions
WHERE status = 'rejected'
`

func (q *Queries) GetRejectedTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getRejectedTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.InvestmentID,
			&i.Category,
			&i.Status,
			&i.Type,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, user_id, amount, investment_id, category, status, type, reason, created_at, updated_at FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id int32) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.InvestmentID,
		&i.Category,
		&i.Status,
		&i.Type,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserFromTransactionID = `-- name: GetUserFromTransactionID :one
SELECT user_id FROM transactions
WHERE id = $1
`

func (q *Queries) GetUserFromTransactionID(ctx context.Context, id int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getUserFromTransactionID, id)
	var user_id int32
	err := row.Scan(&user_id)
	return user_id, err
}

const listAllPayoutRequests = `-- name: ListAllPayoutRequests :many
SELECT id, user_id, account_name, phone_number, bank_name, account_number, investment_id, type, category, amount, created_at, updated_at FROM payout_requests
`

func (q *Queries) ListAllPayoutRequests(ctx context.Context) ([]PayoutRequest, error) {
	rows, err := q.db.QueryContext(ctx, listAllPayoutRequests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PayoutRequest{}
	for rows.Next() {
		var i PayoutRequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountName,
			&i.PhoneNumber,
			&i.BankName,
			&i.AccountNumber,
			&i.InvestmentID,
			&i.Type,
			&i.Category,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayoutRequestsByCategory = `-- name: ListPayoutRequestsByCategory :many
SELECT id, user_id, account_name, phone_number, bank_name, account_number, investment_id, type, category, amount, created_at, updated_at FROM payout_requests
WHERE category = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPayoutRequestsByCategory(ctx context.Context, category string) ([]PayoutRequest, error) {
	rows, err := q.db.QueryContext(ctx, listPayoutRequestsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PayoutRequest{}
	for rows.Next() {
		var i PayoutRequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountName,
			&i.PhoneNumber,
			&i.BankName,
			&i.AccountNumber,
			&i.InvestmentID,
			&i.Type,
			&i.Category,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayoutRequestsByType = `-- name: ListPayoutRequestsByType :many
SELECT id, user_id, account_name, phone_number, bank_name, account_number, investment_id, type, category, amount, created_at, updated_at FROM payout_requests
WHERE type = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPayoutRequestsByType(ctx context.Context, type_ string) ([]PayoutRequest, error) {
	rows, err := q.db.QueryContext(ctx, listPayoutRequestsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PayoutRequest{}
	for rows.Next() {
		var i PayoutRequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountName,
			&i.PhoneNumber,
			&i.BankName,
			&i.AccountNumber,
			&i.InvestmentID,
			&i.Type,
			&i.Category,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayoutRequestsByUserID = `-- name: ListPayoutRequestsByUserID :many
SELECT id, user_id, account_name, phone_number, bank_name, account_number, investment_id, type, category, amount, created_at, updated_at FROM payout_requests
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPayoutRequestsByUserID(ctx context.Context, userID int32) ([]PayoutRequest, error) {
	rows, err := q.db.QueryContext(ctx, listPayoutRequestsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PayoutRequest{}
	for rows.Next() {
		var i PayoutRequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountName,
			&i.PhoneNumber,
			&i.BankName,
			&i.AccountNumber,
			&i.InvestmentID,
			&i.Type,
			&i.Category,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingDepositTransactionsWithUser = `-- name: ListPendingDepositTransactionsWithUser :many
SELECT
  t.id,
  t.user_id,
  t.amount,
  t.type,
  t.status,
  t.reason,
  t.created_at,
  t.updated_at,
  u.username,
  u.email
FROM transactions t
JOIN users u ON t.user_id = u.id
WHERE t.status = 'pending'
AND t.type = 'deposit'
ORDER BY t.created_at DESC
`

type ListPendingDepositTransactionsWithUserRow struct {
	ID        int32          `json:"id"`
	UserID    int32          `json:"user_id"`
	Amount    int32          `json:"amount"`
	Type      string         `json:"type"`
	Status    string         `json:"status"`
	Reason    sql.NullString `json:"reason"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
	Username  string         `json:"username"`
	Email     string         `json:"email"`
}

func (q *Queries) ListPendingDepositTransactionsWithUser(ctx context.Context) ([]ListPendingDepositTransactionsWithUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listPendingDepositTransactionsWithUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingDepositTransactionsWithUserRow{}
	for rows.Next() {
		var i ListPendingDepositTransactionsWithUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Type,
			&i.Status,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingWithdrawalTransactionsWithUser = `-- name: ListPendingWithdrawalTransactionsWithUser :many
SELECT
  t.id,
  t.user_id,
  t.amount,
  t.type,
  t.status,
  t.reason,
  t.created_at,
  t.updated_at,
  u.username,
  u.email
FROM transactions t
JOIN users u ON t.user_id = u.id
WHERE t.status = 'pending'
AND t.type = 'withdrawal'
ORDER BY t.created_at DESC
`

type ListPendingWithdrawalTransactionsWithUserRow struct {
	ID        int32          `json:"id"`
	UserID    int32          `json:"user_id"`
	Amount    int32          `json:"amount"`
	Type      string         `json:"type"`
	Status    string         `json:"status"`
	Reason    sql.NullString `json:"reason"`
	CreatedAt sql.NullTime   `json:"created_at"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
	Username  string         `json:"username"`
	Email     string         `json:"email"`
}

func (q *Queries) ListPendingWithdrawalTransactionsWithUser(ctx context.Context) ([]ListPendingWithdrawalTransactionsWithUserRow, error) {
	rows, err := q.db.QueryContext(ctx, listPendingWithdrawalTransactionsWithUser)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingWithdrawalTransactionsWithUserRow{}
	for rows.Next() {
		var i ListPendingWithdrawalTransactionsWithUserRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Type,
			&i.Status,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByCategory = `-- name: ListTransactionsByCategory :many
SELECT
  transactions.id, transactions.user_id, transactions.amount, transactions.investment_id, transactions.category, transactions.status, transactions.type, transactions.reason, transactions.created_at, transactions.updated_at,
  users.username
FROM transactions
JOIN users ON users.id = transactions.user_id
WHERE transactions.category = $1
ORDER BY transactions.created_at DESC
`

type ListTransactionsByCategoryRow struct {
	ID           int32          `json:"id"`
	UserID       int32          `json:"user_id"`
	Amount       int32          `json:"amount"`
	InvestmentID sql.NullInt32  `json:"investment_id"`
	Category     string         `json:"category"`
	Status       string         `json:"status"`
	Type         string         `json:"type"`
	Reason       sql.NullString `json:"reason"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	Username     string         `json:"username"`
}

func (q *Queries) ListTransactionsByCategory(ctx context.Context, category string) ([]ListTransactionsByCategoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTransactionsByCategoryRow{}
	for rows.Next() {
		var i ListTransactionsByCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.InvestmentID,
			&i.Category,
			&i.Status,
			&i.Type,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByUserID = `-- name: ListTransactionsByUserID :many
SELECT id, user_id, amount, investment_id, category, status, type, reason, created_at, updated_at FROM transactions
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListTransactionsByUserID(ctx context.Context, userID int32) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.InvestmentID,
			&i.Category,
			&i.Status,
			&i.Type,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserInvestmentTransactions = `-- name: ListUserInvestmentTransactions :many
SELECT id, user_id, amount, investment_id, category, status, type, reason, created_at, updated_at FROM transactions
WHERE user_id = $1
  AND type = 'investment'
ORDER BY created_at DESC
`

func (q *Queries) ListUserInvestmentTransactions(ctx context.Context, userID int32) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listUserInvestmentTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.InvestmentID,
			&i.Category,
			&i.Status,
			&i.Type,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSavingsTransactions = `-- name: ListUserSavingsTransactions :many
SELECT id, user_id, amount, investment_id, category, status, type, reason, created_at, updated_at FROM transactions
WHERE user_id = $1
  AND category = 'savings'
ORDER BY created_at DESC
`

func (q *Queries) ListUserSavingsTransactions(ctx context.Context, userID int32) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listUserSavingsTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.InvestmentID,
			&i.Category,
			&i.Status,
			&i.Type,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayoutRequestAmount = `-- name: UpdatePayoutRequestAmount :exec
UPDATE payout_requests
SET amount = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdatePayoutRequestAmountParams struct {
	ID     int32  `json:"id"`
	Amount string `json:"amount"`
}

func (q *Queries) UpdatePayoutRequestAmount(ctx context.Context, arg UpdatePayoutRequestAmountParams) error {
	_, err := q.db.ExecContext(ctx, updatePayoutRequestAmount, arg.ID, arg.Amount)
	return err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :exec
UPDATE transactions
SET status = $2,
    reason = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateTransactionStatusParams struct {
	ID     int32          `json:"id"`
	Status string         `json:"status"`
	Reason sql.NullString `json:"reason"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTransactionStatus, arg.ID, arg.Status, arg.Reason)
	return err
}
