// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: transaction.sql

package db

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createPayoutRequest = `-- name: CreatePayoutRequest :one
INSERT INTO payout_requests (
  user_id, account_name, bank_name, investment_id, type, category, amount
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, account_name, bank_name, investment_id, type, category, amount, created_at, updated_at
`

type CreatePayoutRequestParams struct {
	UserID       uuid.UUID     `json:"user_id"`
	AccountName  string        `json:"account_name"`
	BankName     string        `json:"bank_name"`
	InvestmentID uuid.NullUUID `json:"investment_id"`
	Type         string        `json:"type"`
	Category     string        `json:"category"`
	Amount       string        `json:"amount"`
}

func (q *Queries) CreatePayoutRequest(ctx context.Context, arg CreatePayoutRequestParams) (PayoutRequest, error) {
	row := q.db.QueryRowContext(ctx, createPayoutRequest,
		arg.UserID,
		arg.AccountName,
		arg.BankName,
		arg.InvestmentID,
		arg.Type,
		arg.Category,
		arg.Amount,
	)
	var i PayoutRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountName,
		&i.BankName,
		&i.InvestmentID,
		&i.Type,
		&i.Category,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
  user_id, amount, type, status, reason
) VALUES (
  $1, $2, $3, $4, $5
)
RETURNING id, user_id, amount, type, status, reason, created_at, updated_at
`

type CreateTransactionParams struct {
	UserID uuid.UUID      `json:"user_id"`
	Amount int32          `json:"amount"`
	Type   string         `json:"type"`
	Status string         `json:"status"`
	Reason sql.NullString `json:"reason"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, createTransaction,
		arg.UserID,
		arg.Amount,
		arg.Type,
		arg.Status,
		arg.Reason,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.Type,
		&i.Status,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayoutRequestByID = `-- name: GetPayoutRequestByID :one
SELECT id, user_id, account_name, bank_name, investment_id, type, category, amount, created_at, updated_at FROM payout_requests
WHERE id = $1
`

func (q *Queries) GetPayoutRequestByID(ctx context.Context, id int32) (PayoutRequest, error) {
	row := q.db.QueryRowContext(ctx, getPayoutRequestByID, id)
	var i PayoutRequest
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.AccountName,
		&i.BankName,
		&i.InvestmentID,
		&i.Type,
		&i.Category,
		&i.Amount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRejectedTransactions = `-- name: GetRejectedTransactions :many
SELECT id, user_id, amount, type, status, reason, created_at, updated_at FROM transactions
WHERE status = 'rejected'
`

func (q *Queries) GetRejectedTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, getRejectedTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Type,
			&i.Status,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionByID = `-- name: GetTransactionByID :one
SELECT id, user_id, amount, type, status, reason, created_at, updated_at FROM transactions
WHERE id = $1
`

func (q *Queries) GetTransactionByID(ctx context.Context, id int32) (Transaction, error) {
	row := q.db.QueryRowContext(ctx, getTransactionByID, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Amount,
		&i.Type,
		&i.Status,
		&i.Reason,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserFromTransactionID = `-- name: GetUserFromTransactionID :one
SELECT user_id FROM transactions
WHERE id = $1
`

func (q *Queries) GetUserFromTransactionID(ctx context.Context, id int32) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getUserFromTransactionID, id)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const listPayoutRequestsByCategory = `-- name: ListPayoutRequestsByCategory :many
SELECT id, user_id, account_name, bank_name, investment_id, type, category, amount, created_at, updated_at FROM payout_requests
WHERE category = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPayoutRequestsByCategory(ctx context.Context, category string) ([]PayoutRequest, error) {
	rows, err := q.db.QueryContext(ctx, listPayoutRequestsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PayoutRequest{}
	for rows.Next() {
		var i PayoutRequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountName,
			&i.BankName,
			&i.InvestmentID,
			&i.Type,
			&i.Category,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayoutRequestsByType = `-- name: ListPayoutRequestsByType :many
SELECT id, user_id, account_name, bank_name, investment_id, type, category, amount, created_at, updated_at FROM payout_requests
WHERE type = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPayoutRequestsByType(ctx context.Context, type_ string) ([]PayoutRequest, error) {
	rows, err := q.db.QueryContext(ctx, listPayoutRequestsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PayoutRequest{}
	for rows.Next() {
		var i PayoutRequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountName,
			&i.BankName,
			&i.InvestmentID,
			&i.Type,
			&i.Category,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayoutRequestsByUserID = `-- name: ListPayoutRequestsByUserID :many
SELECT id, user_id, account_name, bank_name, investment_id, type, category, amount, created_at, updated_at FROM payout_requests
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPayoutRequestsByUserID(ctx context.Context, userID uuid.UUID) ([]PayoutRequest, error) {
	rows, err := q.db.QueryContext(ctx, listPayoutRequestsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PayoutRequest{}
	for rows.Next() {
		var i PayoutRequest
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.AccountName,
			&i.BankName,
			&i.InvestmentID,
			&i.Type,
			&i.Category,
			&i.Amount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByType = `-- name: ListTransactionsByType :many
SELECT id, user_id, amount, type, status, reason, created_at, updated_at FROM transactions
WHERE type = $1
ORDER BY created_at DESC
`

func (q *Queries) ListTransactionsByType(ctx context.Context, type_ string) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByType, type_)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Type,
			&i.Status,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByUserID = `-- name: ListTransactionsByUserID :many
SELECT id, user_id, amount, type, status, reason, created_at, updated_at FROM transactions
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListTransactionsByUserID(ctx context.Context, userID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listTransactionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Type,
			&i.Status,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserInvestmentTransactions = `-- name: ListUserInvestmentTransactions :many
SELECT id, user_id, amount, type, status, reason, created_at, updated_at FROM transactions
WHERE user_id = $1
  AND type = 'investment'
ORDER BY created_at DESC
`

func (q *Queries) ListUserInvestmentTransactions(ctx context.Context, userID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listUserInvestmentTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Type,
			&i.Status,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSavingsTransactions = `-- name: ListUserSavingsTransactions :many
SELECT id, user_id, amount, type, status, reason, created_at, updated_at FROM transactions
WHERE user_id = $1
  AND type = 'savings'
ORDER BY created_at DESC
`

func (q *Queries) ListUserSavingsTransactions(ctx context.Context, userID uuid.UUID) ([]Transaction, error) {
	rows, err := q.db.QueryContext(ctx, listUserSavingsTransactions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Amount,
			&i.Type,
			&i.Status,
			&i.Reason,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayoutRequestAmount = `-- name: UpdatePayoutRequestAmount :exec
UPDATE payout_requests
SET amount = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdatePayoutRequestAmountParams struct {
	ID     int32  `json:"id"`
	Amount string `json:"amount"`
}

func (q *Queries) UpdatePayoutRequestAmount(ctx context.Context, arg UpdatePayoutRequestAmountParams) error {
	_, err := q.db.ExecContext(ctx, updatePayoutRequestAmount, arg.ID, arg.Amount)
	return err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :exec
UPDATE transactions
SET status = $2,
    reason = $3,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateTransactionStatusParams struct {
	ID     int32          `json:"id"`
	Status string         `json:"status"`
	Reason sql.NullString `json:"reason"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateTransactionStatus, arg.ID, arg.Status, arg.Reason)
	return err
}
